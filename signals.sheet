
 # Signals
 
 ABRT    Process aborted
 ALRM    Signal raised by alarm
 BUS     Bus error: "access to undefined portion of memory object"
 CHLD    Child process terminated, stopped (or continued*)
 CONT    Continue if stopped
 FPE     Floating point exception: "erroneous arithmetic operation"
 HUP     Hangup
 ILL     Illegal instruction
 INT     Interrupt
 KILL    Kill (terminate immediately)
 PIPE    Write to pipe with no one reading
 QUIT    Quit and dump core
 SEGV    Segmentation violation
 STOP    Stop executing temporarily
 TERM    Termination (request to terminate)
 TSTP    Terminal stop signal
 TTIN    Background process attempting to read from tty ("in")
 TTOU    Background process attempting to write to tty ("out")
 USR1    User-defined 1
 USR2    User-defined 2
 POLL    Pollable event
 PROF    Profiling timer expired
 SYS     Bad syscall
 TRAP    Trace/breakpoint trap
 URG     Urgent data available on socket
 VTALRM  Signal raised by timer counting virtual time: "virtual timer expired"
 XCPU    CPU time limit exceeded
 XFSZ    File size limit exceeded
 
 # Terminal Usage
 
 $ kill <pid>         # Defaults to TERM
 $ kill -n <pid>      # Signal number
 $ kill -NAME <pid>   # Signal name
 
 $ kill 333           # All send TERM to process 333
 $ kill -15 333       # All send TERM to process 333
 $ kill -TERM 333     # All send TERM to process 333
 
 # Ruby Usage
 
 trap :TERM do
   # Handle TERM signal
 end
 
 # Details
 
 ## ABRT
 
 SIGABRT is sent by the process to itself when it calls the abort libc function, defined in stdlib.h. The SIGABRT signal can be caught, but it cannot be blocked; if the signal handler returns then all open streams are closed and flushed and the program terminates (dumping core if appropriate). This means that the abort call never returns. Because of this characteristic, it is often used to signal fatal conditions in support libraries, situations where the current operation cannot be completed but the main program can perform cleanup before exiting. It is also used if an assertion fails.
 
 ## ALRM
 
 Computer programs often use SIGALRM to make a long-running action time out, or to provide a way of performing an action at regular intervals.
 SIGALRM is generally raised a whole number of seconds after an alarm system call is made. It is sometimes used to implement the sleep function; consequently, programs cannot reliably use alarm to "wake up" from a delay caused by slee
 
 ## BUS
 
 SIGBUS is usually generated by the operating system, but users with appropriate permissions can use the kill system call or kill command (a userland program, or sometimes a shell builtin) to send the signal to a process at will.
 
 ## CHLD
 
 POSIX.1-2001 allows a parent process to elect for the kernel to automatically reap child processes that terminate by setting the disposition of SIGCHLD to SIG_IGN or by setting the SA_NOCLDWAIT flag for the SIGCHLD signal; Linux 2.6 kernels adhere to this behavior while FreeBSD supports only the latter of these methods [3]. Because of historical differences between System V and BSD behaviors with regard to ignoring SIGCHLD, calling wait remains the most portable paradigm for cleaning up after forked child processes
 
 ## CONT
 
 When SIGSTOP or SIGTSTP is sent to a process, the usual behaviour is to pause that process in its current state. The process will only resume execution if it is sent the SIGCONT signal. SIGSTOP and SIGCONT are used for job control in the Unix shell, among other purposes.
 
 ## FPE
 
 ## HUP
 
 ## ILL
 
 ## INT
 
 ## KILL
 
 ## PIPE
 
 ## QUIT
 
 ## SEGV
 
 ## STOP
 
 ## TERM
 
 ## STP
 
 ## TTIN
 
 ## TTOU
 
 ## USR1
 
 ## USR2
 
 ## POLL
 
 ## PROF
 
 ## SYS
 
 ## TRAP
 
 ## URG
 
 ## VTALRM
 
 ## XCPU
 
 ## XFSZ
 
 